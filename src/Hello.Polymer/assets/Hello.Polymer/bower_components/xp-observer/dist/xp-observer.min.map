{"version":3,"sources":["../../../../usr/lib/node_modules/browserify/node_modules/browser-pack/_prelude.js","index","lib/index.js","node_modules/observe-js/src/observe.js"],"names":["global","XP","require","Observer","ObjectObserver","module","exports","XPObserver","Class","initialize","value","callback","deep","assertArgument","isObservable","isFunction","self","this","_observers","_addObserver","disconnect","_removeObserver","enumerable","wrapper","isVoid","isCollection","observe","sub","undefined","observer","_isObserved","includesDeep","_connectObserver","_observer","push","isArray","isObject","_getObserved","added","removed","changed","getOld","forEach","key","open","value_","_getObserver","find","close","pull","set","val","validate","window","detectObjectObserve","recs","records","Object","Array","test","arr","id","length","deliverChangeRecords","type","unobserve","detectEval","chrome","app","runtime","navigator","getDeviceStorage","f","Function","ex","isIndex","s","toNumber","obj","areSameValue","left","right","numberIsNaN","getPathCharType","char","code","charCodeAt","noop","parsePath","path","maybeUnescapeQuote","index","nextChar","mode","newChar","actions","append","c","transition","action","typeMap","keys","pathStateMachine","isIdent","identRegExp","Path","parts","privateToken","constructorIsPrivate","Error","i","String","hasEval","getValueFrom","compiledGetValueFromFn","getPath","pathString","pathCache","invalidPath","formatAccessor","replace","dirtyCheck","cycles","MAX_DIRTY_CHECK_CYCLES","check_","testingExposeCycleCount","dirtyCheckCycleCount","objectIsEmpty","object","prop","diffIsEmpty","diff","diffObjectFromOldObject","oldObject","newValue","runEOMTasks","eomTasks","newObservedObject","state_","OPENED","discardRecords","first","obs","arrayObserve","deliver","discard","observedObjectCache","getObservedObject","dir","pop","newObservedSet","rootObj","rootObjProps","objects","indexOf","getPrototypeOf","allRootObjNonObservedProps","rec","name","observers","iterateObjects_","observerCount","record","rootObject","unobservedCount","observedSetCache","lastObservedSet","getObservedSet","UNOPENED","callback_","target_","directObserver_","id_","nextObserverId","addToAll","_allObserversCount","collectObservers","allObservers","removeFromAll","call","oldObject_","ArrayObserver","array","PathObserver","defaultValue","object_","path_","defaultValue_","CompoundObserver","reportChangesOnOpen","reportChangesOnOpen_","observed_","identFn","ObserverTransform","observable","getValueFn","setValueFn","dontPassThroughSet","observable_","getValueFn_","setValueFn_","dontPassThroughSet_","diffObjectFromChangeRecords","changeRecords","oldValues","expectedRecordTypes","oldValue","console","error","newSplice","addedCount","ArraySplice","calcSplices","current","currentStart","currentEnd","old","oldStart","oldEnd","arraySplice","intersect","start1","end1","start2","end2","mergeSplice","splices","splice","inserted","insertionOffset","intersectCount","deleteCount","prepend","slice","prototype","apply","offset","createInitialSplices","JSON","stringify","projectArraySplices","concat","hasObserve","Number","isNaN","createObject","proto","__proto__","newObject","create","getOwnPropertyNames","defineProperty","getOwnPropertyDescriptor","identStart","identPart","RegExp","beforePath","ws","ident","[","eof","inPath",".","beforeIdent","inIdent","0","number","beforeElement","'","\"","afterZero","]","inIndex","inSingleQuote","else","inDoubleQuote","afterElement","get","valid","toString","iterateObjects","str","keyIsIdent","keyForInOperator","setValueFrom","runEOM","fn","Promise","resolve","then","CLOSED","RESETTING","target","connect_","disconnect_","report_","changes","_errorThrownDuringCallback","stack","discardChanges","runningMicrotaskCheckpoint","Platform","performMicrotaskCheckpoint","anyChanged","toCheck","clearObservers","copyObject","copy","skipChanges","property","applySplices","previous","spliceArgs","addIndex","setValue","observerSentinel","needsDirectObserver","addPath","addObserver","startReset","finishReset","observedCallback_","add","update","delete","EDIT_LEAVE","EDIT_UPDATE","EDIT_ADD","EDIT_DELETE","calcEditDistances","j","rowCount","columnCount","distances","equals","north","west","spliceOperationsFromEditDistances","edits","min","northWest","reverse","prefixCount","suffixCount","minLength","Math","sharedPrefix","sharedSuffix","ops","oldIndex","searchLength","index1","index2","count","calculateSplices","currentValue","previousValue","expose","nodeType","runEOM_","observerSentinel_","hasObjectObserve"],"mappings":"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","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports=require(\"./lib\");","/*jslint browser: true, devel: true, node: true, ass: true, nomen: true, unparam: true, indent: 4 */\n\n/**\n * @license\n * Copyright (c) 2015 The ExpandJS authors. All rights reserved.\n * This code may only be used under the BSD style license found at https://expandjs.github.io/LICENSE.txt\n * The complete set of authors may be found at https://expandjs.github.io/AUTHORS.txt\n * The complete set of contributors may be found at https://expandjs.github.io/CONTRIBUTORS.txt\n */\n(function (global) {\n    \"use strict\";\n\n    // Vars\n    var XP       = global.XP || require('expandjs'),\n        Observer = require('observe-js').ObjectObserver;\n\n    /*********************************************************************/\n\n    /**\n     * This class is used to provide object observing functionality.\n     *\n     * @class XPObserver\n     * @description This class is used to provide object observing functionality\n     */\n    module.exports = global.XPObserver = new XP.Class('XPObserver', {\n\n        /**\n         * @constructs\n         * @param {Array | Function | Object} value\n         * @param {Function} callback\n         * @param {boolean} [deep = false]\n         */\n        initialize: function (value, callback, deep) {\n\n            // Asserting\n            XP.assertArgument(XP.isObservable(value), 1, 'Array, Function or Object');\n            XP.assertArgument(XP.isFunction(callback), 2, 'Function');\n\n            // Vars\n            var self = this;\n\n            // Setting\n            self.value      = value;\n            self.callback   = callback;\n            self.deep       = deep;\n            self._observers = [];\n\n            // Observing\n            self._addObserver(self.value);\n\n            return self;\n        },\n\n        /*********************************************************************/\n\n        /**\n         * Disconnects the observer.\n         *\n         * @method disconnect\n         * @returns {Object}\n         */\n        disconnect: function () {\n            var self = this;\n            self._removeObserver(self.value);\n            return self;\n        },\n\n        /*********************************************************************/\n\n        /**\n         * Adds the observer for value.\n         *\n         * @method _addObserver\n         * @param {Array | Function | Object} value\n         * @param {Array | Object} [wrapper]\n         * @returns {Object}\n         * @private\n         */\n        _addObserver: {\n            enumerable: false,\n            value: function (value, wrapper) {\n\n                // Asserting\n                XP.assertArgument(XP.isObservable(value), 1, 'Array, Function or Object');\n                XP.assertArgument(XP.isVoid(wrapper) || XP.isCollection(wrapper), 2, 'Array or Object');\n\n                // Vars\n                var self     = this,\n                    observe  = function (sub) { return XP.isObservable(sub) ? self._addObserver(sub, value) : undefined; },\n                    observer = !self._isObserved(value) && (!wrapper || XP.includesDeep(wrapper, value)) && self._connectObserver(new Observer(value));\n\n                // Checking\n                if (!observer) { return self; }\n\n                // Adding\n                if (value === self.value) { self._observer = observer; } else { XP.push(self._observers, observer); }\n                if (self.deep && XP.isCollection(value)) { XP[XP.isArray(value) ? 'forEach' : 'forOwn'](value, observe); }\n\n                return self;\n            }\n        },\n\n        /**\n         * Connects an observer.\n         *\n         * @method _connectObserver\n         * @param {Object} observer\n         * @returns {Object}\n         * @private\n         */\n        _connectObserver: {\n            enumerable: false,\n            value: function (observer) {\n\n                // Asserting\n                XP.assertArgument(XP.isObject(observer), 1, 'Object');\n\n                // Vars\n                var self     = this,\n                    value    = self._getObserved(observer),\n                    callback = function (added, removed, changed, getOld) {\n\n                        // Updating\n                        XP.forEach(added,   function (sub)      { return XP.isObservable(sub) ? self._addObserver(sub, value) : undefined; });\n                        XP.forEach(changed, function (sub, key) { return XP.isObservable(sub) ? self._removeObserver(getOld(key))._addObserver(sub, value) : undefined; });\n                        XP.forEach(removed, function (sub, key) { return XP.isObservable(getOld(key)) ? self._removeObserver(getOld(key)) : undefined; });\n\n                        return self.callback(self.value);\n                    };\n\n                // Opening\n                observer.open(callback);\n\n                return observer;\n            }\n        },\n\n        /**\n         * Returns the value of observer.\n         *\n         * @method _getObserved\n         * @param {Object} observer\n         * @returns {Array | Object}\n         * @private\n         */\n        _getObserved: {\n            enumerable: false,\n            value: function (observer) {\n                XP.assertArgument(XP.isObject(observer), 1, 'Object');\n                return observer.value_;\n            }\n        },\n\n        /**\n         * Returns the observer of value.\n         *\n         * @method _getObserver\n         * @param {Array | Function | Object} value\n         * @returns {Object | undefined}\n         * @private\n         */\n        _getObserver: {\n            enumerable: false,\n            value: function (value) {\n                XP.assertArgument(XP.isObservable(value), 1, 'Array, Function or Object');\n                return XP.find(this._observers, function (observer) { return observer.value_ === value; });\n            }\n        },\n\n        /**\n         * Returns true if value is observed.\n         *\n         * @method _isObserved\n         * @param {Array | Function | Object} value\n         * @returns {boolean}\n         * @private\n         */\n        _isObserved: {\n            enumerable: false,\n            value: function (value) {\n                XP.assertArgument(XP.isObservable(value), 1, 'Array, Function or Object');\n                return value === this.value ? !!this._observer : !!this._getObserver(value);\n            }\n        },\n\n        /**\n         * Removes the observer of value.\n         *\n         * @method _removeObserver\n         * @param {Array | Function | Object} value\n         * @returns {Object}\n         * @private\n         */\n        _removeObserver: {\n            enumerable: false,\n            value: function (value) {\n\n                // Asserting\n                XP.assertArgument(XP.isObservable(value), 1, 'Array, Function or Object');\n\n                // Vars\n                var self     = this,\n                    observe  = function (sub) { return XP.isObservable(sub) ? self._removeObserver(sub) : undefined; },\n                    observer = !XP.includesDeep(self.value, value) && self._getObserver(value);\n\n                // Closing\n                if (observer) { observer.close(); } else { return self; }\n\n                // Removing\n                if (value === self.value) { self._observer = observer; } else { XP.pull(self._observers, observer); }\n                if (self.deep && XP.isCollection(value)) { XP[XP.isArray(value) ? 'forEach' : 'forOwn'](value, observe); }\n\n                return self;\n            }\n        },\n\n        /*********************************************************************/\n\n        /**\n         * TODO DOC\n         *\n         * @property callback\n         * @type Function\n         */\n        callback: {\n            set: function (val) { return this.callback || val; },\n            validate: function (val) { return !XP.isFunction(val) && 'Function'; }\n        },\n\n        /**\n         * TODO DOC\n         *\n         * @property deep\n         * @type boolean\n         */\n        deep: {\n            set: function (val) { return !!val; }\n        },\n\n        /**\n         * TODO DOC\n         *\n         * @property value\n         * @type Array | Function | Object\n         */\n        value: {\n            set: function (val) { return this.value || val; },\n            validate: function (val) { return !XP.isObservable(val) && 'Array, Function or Object'; }\n        },\n\n        /*********************************************************************/\n\n        /**\n         * TODO DOC\n         *\n         * @property _observer\n         * @type Object\n         * @private\n         */\n        _observer: {\n            enumerable: false,\n            set: function (val) { return this._observer || val; },\n            validate: function (val) { return !XP.isObject(val) && 'Object'; }\n        },\n\n        /**\n         * TODO DOC\n         *\n         * @property _observers\n         * @type Array\n         * @private\n         */\n        _observers: {\n            enumerable: false,\n            set: function (val) { return this._observers || val; },\n            validate: function (val) { return !XP.isArray(val) && 'Array'; }\n        }\n    });\n\n}(typeof window !== \"undefined\" ? window : global));\n","/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(global) {\n  'use strict';\n\n  var testingExposeCycleCount = global.testingExposeCycleCount;\n\n  // Detect and do basic sanity checking on Object/Array.observe.\n  function detectObjectObserve() {\n    if (typeof Object.observe !== 'function' ||\n        typeof Array.observe !== 'function') {\n      return false;\n    }\n\n    var records = [];\n\n    function callback(recs) {\n      records = recs;\n    }\n\n    var test = {};\n    var arr = [];\n    Object.observe(test, callback);\n    Array.observe(arr, callback);\n    test.id = 1;\n    test.id = 2;\n    delete test.id;\n    arr.push(1, 2);\n    arr.length = 0;\n\n    Object.deliverChangeRecords(callback);\n    if (records.length !== 5)\n      return false;\n\n    if (records[0].type != 'add' ||\n        records[1].type != 'update' ||\n        records[2].type != 'delete' ||\n        records[3].type != 'splice' ||\n        records[4].type != 'splice') {\n      return false;\n    }\n\n    Object.unobserve(test, callback);\n    Array.unobserve(arr, callback);\n\n    return true;\n  }\n\n  var hasObserve = detectObjectObserve();\n\n  function detectEval() {\n    // Don't test for eval if we're running in a Chrome App environment.\n    // We check for APIs set that only exist in a Chrome App context.\n    if (typeof chrome !== 'undefined' && chrome.app && chrome.app.runtime) {\n      return false;\n    }\n\n    // Firefox OS Apps do not allow eval. This feature detection is very hacky\n    // but even if some other platform adds support for this function this code\n    // will continue to work.\n    if (typeof navigator != 'undefined' && navigator.getDeviceStorage) {\n      return false;\n    }\n\n    try {\n      var f = new Function('', 'return true;');\n      return f();\n    } catch (ex) {\n      return false;\n    }\n  }\n\n  var hasEval = detectEval();\n\n  function isIndex(s) {\n    return +s === s >>> 0 && s !== '';\n  }\n\n  function toNumber(s) {\n    return +s;\n  }\n\n  function isObject(obj) {\n    return obj === Object(obj);\n  }\n\n  var numberIsNaN = global.Number.isNaN || function(value) {\n    return typeof value === 'number' && global.isNaN(value);\n  };\n\n  function areSameValue(left, right) {\n    if (left === right)\n      return left !== 0 || 1 / left === 1 / right;\n    if (numberIsNaN(left) && numberIsNaN(right))\n      return true;\n\n    return left !== left && right !== right;\n  }\n\n  var createObject = ('__proto__' in {}) ?\n    function(obj) { return obj; } :\n    function(obj) {\n      var proto = obj.__proto__;\n      if (!proto)\n        return obj;\n      var newObject = Object.create(proto);\n      Object.getOwnPropertyNames(obj).forEach(function(name) {\n        Object.defineProperty(newObject, name,\n                             Object.getOwnPropertyDescriptor(obj, name));\n      });\n      return newObject;\n    };\n\n  var identStart = '[\\$_a-zA-Z]';\n  var identPart = '[\\$_a-zA-Z0-9]';\n  var identRegExp = new RegExp('^' + identStart + '+' + identPart + '*' + '$');\n\n  function getPathCharType(char) {\n    if (char === undefined)\n      return 'eof';\n\n    var code = char.charCodeAt(0);\n\n    switch(code) {\n      case 0x5B: // [\n      case 0x5D: // ]\n      case 0x2E: // .\n      case 0x22: // \"\n      case 0x27: // '\n      case 0x30: // 0\n        return char;\n\n      case 0x5F: // _\n      case 0x24: // $\n        return 'ident';\n\n      case 0x20: // Space\n      case 0x09: // Tab\n      case 0x0A: // Newline\n      case 0x0D: // Return\n      case 0xA0:  // No-break space\n      case 0xFEFF:  // Byte Order Mark\n      case 0x2028:  // Line Separator\n      case 0x2029:  // Paragraph Separator\n        return 'ws';\n    }\n\n    // a-z, A-Z\n    if ((0x61 <= code && code <= 0x7A) || (0x41 <= code && code <= 0x5A))\n      return 'ident';\n\n    // 1-9\n    if (0x31 <= code && code <= 0x39)\n      return 'number';\n\n    return 'else';\n  }\n\n  var pathStateMachine = {\n    'beforePath': {\n      'ws': ['beforePath'],\n      'ident': ['inIdent', 'append'],\n      '[': ['beforeElement'],\n      'eof': ['afterPath']\n    },\n\n    'inPath': {\n      'ws': ['inPath'],\n      '.': ['beforeIdent'],\n      '[': ['beforeElement'],\n      'eof': ['afterPath']\n    },\n\n    'beforeIdent': {\n      'ws': ['beforeIdent'],\n      'ident': ['inIdent', 'append']\n    },\n\n    'inIdent': {\n      'ident': ['inIdent', 'append'],\n      '0': ['inIdent', 'append'],\n      'number': ['inIdent', 'append'],\n      'ws': ['inPath', 'push'],\n      '.': ['beforeIdent', 'push'],\n      '[': ['beforeElement', 'push'],\n      'eof': ['afterPath', 'push']\n    },\n\n    'beforeElement': {\n      'ws': ['beforeElement'],\n      '0': ['afterZero', 'append'],\n      'number': ['inIndex', 'append'],\n      \"'\": ['inSingleQuote', 'append', ''],\n      '\"': ['inDoubleQuote', 'append', '']\n    },\n\n    'afterZero': {\n      'ws': ['afterElement', 'push'],\n      ']': ['inPath', 'push']\n    },\n\n    'inIndex': {\n      '0': ['inIndex', 'append'],\n      'number': ['inIndex', 'append'],\n      'ws': ['afterElement'],\n      ']': ['inPath', 'push']\n    },\n\n    'inSingleQuote': {\n      \"'\": ['afterElement'],\n      'eof': ['error'],\n      'else': ['inSingleQuote', 'append']\n    },\n\n    'inDoubleQuote': {\n      '\"': ['afterElement'],\n      'eof': ['error'],\n      'else': ['inDoubleQuote', 'append']\n    },\n\n    'afterElement': {\n      'ws': ['afterElement'],\n      ']': ['inPath', 'push']\n    }\n  };\n\n  function noop() {}\n\n  function parsePath(path) {\n    var keys = [];\n    var index = -1;\n    var c, newChar, key, type, transition, action, typeMap, mode = 'beforePath';\n\n    var actions = {\n      push: function() {\n        if (key === undefined)\n          return;\n\n        keys.push(key);\n        key = undefined;\n      },\n\n      append: function() {\n        if (key === undefined)\n          key = newChar;\n        else\n          key += newChar;\n      }\n    };\n\n    function maybeUnescapeQuote() {\n      if (index >= path.length)\n        return;\n\n      var nextChar = path[index + 1];\n      if ((mode == 'inSingleQuote' && nextChar == \"'\") ||\n          (mode == 'inDoubleQuote' && nextChar == '\"')) {\n        index++;\n        newChar = nextChar;\n        actions.append();\n        return true;\n      }\n    }\n\n    while (mode) {\n      index++;\n      c = path[index];\n\n      if (c == '\\\\' && maybeUnescapeQuote(mode))\n        continue;\n\n      type = getPathCharType(c);\n      typeMap = pathStateMachine[mode];\n      transition = typeMap[type] || typeMap['else'] || 'error';\n\n      if (transition == 'error')\n        return; // parse error;\n\n      mode = transition[0];\n      action = actions[transition[1]] || noop;\n      newChar = transition[2] === undefined ? c : transition[2];\n      action();\n\n      if (mode === 'afterPath') {\n        return keys;\n      }\n    }\n\n    return; // parse error\n  }\n\n  function isIdent(s) {\n    return identRegExp.test(s);\n  }\n\n  var constructorIsPrivate = {};\n\n  function Path(parts, privateToken) {\n    if (privateToken !== constructorIsPrivate)\n      throw Error('Use Path.get to retrieve path objects');\n\n    for (var i = 0; i < parts.length; i++) {\n      this.push(String(parts[i]));\n    }\n\n    if (hasEval && this.length) {\n      this.getValueFrom = this.compiledGetValueFromFn();\n    }\n  }\n\n  // TODO(rafaelw): Make simple LRU cache\n  var pathCache = {};\n\n  function getPath(pathString) {\n    if (pathString instanceof Path)\n      return pathString;\n\n    if (pathString == null || pathString.length == 0)\n      pathString = '';\n\n    if (typeof pathString != 'string') {\n      if (isIndex(pathString.length)) {\n        // Constructed with array-like (pre-parsed) keys\n        return new Path(pathString, constructorIsPrivate);\n      }\n\n      pathString = String(pathString);\n    }\n\n    var path = pathCache[pathString];\n    if (path)\n      return path;\n\n    var parts = parsePath(pathString);\n    if (!parts)\n      return invalidPath;\n\n    path = new Path(parts, constructorIsPrivate);\n    pathCache[pathString] = path;\n    return path;\n  }\n\n  Path.get = getPath;\n\n  function formatAccessor(key) {\n    if (isIndex(key)) {\n      return '[' + key + ']';\n    } else {\n      return '[\"' + key.replace(/\"/g, '\\\\\"') + '\"]';\n    }\n  }\n\n  Path.prototype = createObject({\n    __proto__: [],\n    valid: true,\n\n    toString: function() {\n      var pathString = '';\n      for (var i = 0; i < this.length; i++) {\n        var key = this[i];\n        if (isIdent(key)) {\n          pathString += i ? '.' + key : key;\n        } else {\n          pathString += formatAccessor(key);\n        }\n      }\n\n      return pathString;\n    },\n\n    getValueFrom: function(obj, defaultValue) {\n      for (var i = 0; i < this.length; i++) {\n        var key = this[i];\n        if (obj == null || !(key in obj))\n          return defaultValue;\n        obj = obj[key];\n      }\n      return obj;\n    },\n\n    iterateObjects: function(obj, observe) {\n      for (var i = 0; i < this.length; i++) {\n        if (i)\n          obj = obj[this[i - 1]];\n        if (!isObject(obj))\n          return;\n        observe(obj, this[i]);\n      }\n    },\n\n    compiledGetValueFromFn: function() {\n      var str = '';\n      var pathString = 'obj';\n      str += 'if (obj != null';\n      var i = 0;\n      var key;\n      for (; i < (this.length - 1); i++) {\n        key = this[i];\n        pathString += isIdent(key) ? '.' + key : formatAccessor(key);\n        str += ' &&\\n    ' + pathString + ' != null';\n      }\n\n      key = this[i];\n      var keyIsIdent = isIdent(key);\n      var keyForInOperator = keyIsIdent ? '\"' + key.replace(/\"/g, '\\\\\"') + '\"' : key;\n      str += ' &&\\n    ' + keyForInOperator + ' in ' + pathString + ')\\n';\n      pathString += keyIsIdent ? '.' + key : formatAccessor(key);\n\n      str += '  return ' + pathString + ';\\nelse\\n  return defaultValue;';\n      return new Function('obj', 'defaultValue', str);\n    },\n\n    setValueFrom: function(obj, value) {\n      if (!this.length)\n        return false;\n\n      for (var i = 0; i < this.length - 1; i++) {\n        if (!isObject(obj))\n          return false;\n        obj = obj[this[i]];\n      }\n\n      if (!isObject(obj))\n        return false;\n\n      obj[this[i]] = value;\n      return true;\n    }\n  });\n\n  var invalidPath = new Path('', constructorIsPrivate);\n  invalidPath.valid = false;\n  invalidPath.getValueFrom = invalidPath.setValueFrom = function() {};\n\n  var MAX_DIRTY_CHECK_CYCLES = 1000;\n\n  function dirtyCheck(observer) {\n    var cycles = 0;\n    while (cycles < MAX_DIRTY_CHECK_CYCLES && observer.check_()) {\n      cycles++;\n    }\n    if (testingExposeCycleCount)\n      global.dirtyCheckCycleCount = cycles;\n\n    return cycles > 0;\n  }\n\n  function objectIsEmpty(object) {\n    for (var prop in object)\n      return false;\n    return true;\n  }\n\n  function diffIsEmpty(diff) {\n    return objectIsEmpty(diff.added) &&\n           objectIsEmpty(diff.removed) &&\n           objectIsEmpty(diff.changed);\n  }\n\n  function diffObjectFromOldObject(object, oldObject) {\n    var added = {};\n    var removed = {};\n    var changed = {};\n    var prop;\n\n    for (prop in oldObject) {\n      var newValue = object[prop];\n\n      if (newValue !== undefined && newValue === oldObject[prop])\n        continue;\n\n      if (!(prop in object)) {\n        removed[prop] = undefined;\n        continue;\n      }\n\n      if (newValue !== oldObject[prop])\n        changed[prop] = newValue;\n    }\n\n    for (prop in object) {\n      if (prop in oldObject)\n        continue;\n\n      added[prop] = object[prop];\n    }\n\n    if (Array.isArray(object) && object.length !== oldObject.length)\n      changed.length = object.length;\n\n    return {\n      added: added,\n      removed: removed,\n      changed: changed\n    };\n  }\n\n  var eomTasks = [];\n  function runEOMTasks() {\n    if (!eomTasks.length)\n      return false;\n\n    for (var i = 0; i < eomTasks.length; i++) {\n      eomTasks[i]();\n    }\n    eomTasks.length = 0;\n    return true;\n  }\n\n  var runEOM = hasObserve ? (function(){\n    return function(fn) {\n      return Promise.resolve().then(fn);\n    };\n  })() :\n  (function() {\n    return function(fn) {\n      eomTasks.push(fn);\n    };\n  })();\n\n  var observedObjectCache = [];\n\n  function newObservedObject() {\n    var observer;\n    var object;\n    var discardRecords = false;\n    var first = true;\n\n    function callback(records) {\n      if (observer && observer.state_ === OPENED && !discardRecords)\n        observer.check_(records);\n    }\n\n    return {\n      open: function(obs) {\n        if (observer)\n          throw Error('ObservedObject in use');\n\n        if (!first)\n          Object.deliverChangeRecords(callback);\n\n        observer = obs;\n        first = false;\n      },\n      observe: function(obj, arrayObserve) {\n        object = obj;\n        if (arrayObserve)\n          Array.observe(object, callback);\n        else\n          Object.observe(object, callback);\n      },\n      deliver: function(discard) {\n        discardRecords = discard;\n        Object.deliverChangeRecords(callback);\n        discardRecords = false;\n      },\n      close: function() {\n        observer = undefined;\n        Object.unobserve(object, callback);\n        observedObjectCache.push(this);\n      }\n    };\n  }\n\n  /*\n   * The observedSet abstraction is a perf optimization which reduces the total\n   * number of Object.observe observations of a set of objects. The idea is that\n   * groups of Observers will have some object dependencies in common and this\n   * observed set ensures that each object in the transitive closure of\n   * dependencies is only observed once. The observedSet acts as a write barrier\n   * such that whenever any change comes through, all Observers are checked for\n   * changed values.\n   *\n   * Note that this optimization is explicitly moving work from setup-time to\n   * change-time.\n   *\n   * TODO(rafaelw): Implement \"garbage collection\". In order to move work off\n   * the critical path, when Observers are closed, their observed objects are\n   * not Object.unobserve(d). As a result, it's possible that if the observedSet\n   * is kept open, but some Observers have been closed, it could cause \"leaks\"\n   * (prevent otherwise collectable objects from being collected). At some\n   * point, we should implement incremental \"gc\" which keeps a list of\n   * observedSets which may need clean-up and does small amounts of cleanup on a\n   * timeout until all is clean.\n   */\n\n  function getObservedObject(observer, object, arrayObserve) {\n    var dir = observedObjectCache.pop() || newObservedObject();\n    dir.open(observer);\n    dir.observe(object, arrayObserve);\n    return dir;\n  }\n\n  var observedSetCache = [];\n\n  function newObservedSet() {\n    var observerCount = 0;\n    var observers = [];\n    var objects = [];\n    var rootObj;\n    var rootObjProps;\n\n    function observe(obj, prop) {\n      if (!obj)\n        return;\n\n      if (obj === rootObj)\n        rootObjProps[prop] = true;\n\n      if (objects.indexOf(obj) < 0) {\n        objects.push(obj);\n        Object.observe(obj, callback);\n      }\n\n      observe(Object.getPrototypeOf(obj), prop);\n    }\n\n    function allRootObjNonObservedProps(recs) {\n      for (var i = 0; i < recs.length; i++) {\n        var rec = recs[i];\n        if (rec.object !== rootObj ||\n            rootObjProps[rec.name] ||\n            rec.type === 'setPrototype') {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    function callback(recs) {\n      if (allRootObjNonObservedProps(recs))\n        return;\n\n      var i, observer;\n      for (i = 0; i < observers.length; i++) {\n        observer = observers[i];\n        if (observer.state_ == OPENED) {\n          observer.iterateObjects_(observe);\n        }\n      }\n\n      for (i = 0; i < observers.length; i++) {\n        observer = observers[i];\n        if (observer.state_ == OPENED) {\n          observer.check_();\n        }\n      }\n    }\n\n    var record = {\n      objects: objects,\n      get rootObject() { return rootObj; },\n      set rootObject(value) {\n        rootObj = value;\n        rootObjProps = {};\n      },\n      open: function(obs, object) {\n        observers.push(obs);\n        observerCount++;\n        obs.iterateObjects_(observe);\n      },\n      close: function(obs) {\n        observerCount--;\n        if (observerCount > 0) {\n          return;\n        }\n\n        for (var i = 0; i < objects.length; i++) {\n          Object.unobserve(objects[i], callback);\n          Observer.unobservedCount++;\n        }\n\n        observers.length = 0;\n        objects.length = 0;\n        rootObj = undefined;\n        rootObjProps = undefined;\n        observedSetCache.push(this);\n        if (lastObservedSet === this)\n          lastObservedSet = null;\n      },\n    };\n\n    return record;\n  }\n\n  var lastObservedSet;\n\n  function getObservedSet(observer, obj) {\n    if (!lastObservedSet || lastObservedSet.rootObject !== obj) {\n      lastObservedSet = observedSetCache.pop() || newObservedSet();\n      lastObservedSet.rootObject = obj;\n    }\n    lastObservedSet.open(observer, obj);\n    return lastObservedSet;\n  }\n\n  var UNOPENED = 0;\n  var OPENED = 1;\n  var CLOSED = 2;\n  var RESETTING = 3;\n\n  var nextObserverId = 1;\n\n  function Observer() {\n    this.state_ = UNOPENED;\n    this.callback_ = undefined;\n    this.target_ = undefined; // TODO(rafaelw): Should be WeakRef\n    this.directObserver_ = undefined;\n    this.value_ = undefined;\n    this.id_ = nextObserverId++;\n  }\n\n  Observer.prototype = {\n    open: function(callback, target) {\n      if (this.state_ != UNOPENED)\n        throw Error('Observer has already been opened.');\n\n      addToAll(this);\n      this.callback_ = callback;\n      this.target_ = target;\n      this.connect_();\n      this.state_ = OPENED;\n      return this.value_;\n    },\n\n    close: function() {\n      if (this.state_ != OPENED)\n        return;\n\n      removeFromAll(this);\n      this.disconnect_();\n      this.value_ = undefined;\n      this.callback_ = undefined;\n      this.target_ = undefined;\n      this.state_ = CLOSED;\n    },\n\n    deliver: function() {\n      if (this.state_ != OPENED)\n        return;\n\n      dirtyCheck(this);\n    },\n\n    report_: function(changes) {\n      try {\n        this.callback_.apply(this.target_, changes);\n      } catch (ex) {\n        Observer._errorThrownDuringCallback = true;\n        console.error('Exception caught during observer callback: ' +\n                       (ex.stack || ex));\n      }\n    },\n\n    discardChanges: function() {\n      this.check_(undefined, true);\n      return this.value_;\n    }\n  };\n\n  var collectObservers = !hasObserve;\n  var allObservers;\n  Observer._allObserversCount = 0;\n\n  if (collectObservers) {\n    allObservers = [];\n  }\n\n  function addToAll(observer) {\n    Observer._allObserversCount++;\n    if (!collectObservers)\n      return;\n\n    allObservers.push(observer);\n  }\n\n  function removeFromAll(observer) {\n    Observer._allObserversCount--;\n  }\n\n  var runningMicrotaskCheckpoint = false;\n\n  global.Platform = global.Platform || {};\n\n  global.Platform.performMicrotaskCheckpoint = function() {\n    if (runningMicrotaskCheckpoint)\n      return;\n\n    if (!collectObservers)\n      return;\n\n    runningMicrotaskCheckpoint = true;\n\n    var cycles = 0;\n    var anyChanged, toCheck;\n\n    do {\n      cycles++;\n      toCheck = allObservers;\n      allObservers = [];\n      anyChanged = false;\n\n      for (var i = 0; i < toCheck.length; i++) {\n        var observer = toCheck[i];\n        if (observer.state_ != OPENED)\n          continue;\n\n        if (observer.check_())\n          anyChanged = true;\n\n        allObservers.push(observer);\n      }\n      if (runEOMTasks())\n        anyChanged = true;\n    } while (cycles < MAX_DIRTY_CHECK_CYCLES && anyChanged);\n\n    if (testingExposeCycleCount)\n      global.dirtyCheckCycleCount = cycles;\n\n    runningMicrotaskCheckpoint = false;\n  };\n\n  if (collectObservers) {\n    global.Platform.clearObservers = function() {\n      allObservers = [];\n    };\n  }\n\n  function ObjectObserver(object) {\n    Observer.call(this);\n    this.value_ = object;\n    this.oldObject_ = undefined;\n  }\n\n  ObjectObserver.prototype = createObject({\n    __proto__: Observer.prototype,\n\n    arrayObserve: false,\n\n    connect_: function(callback, target) {\n      if (hasObserve) {\n        this.directObserver_ = getObservedObject(this, this.value_,\n                                                 this.arrayObserve);\n      } else {\n        this.oldObject_ = this.copyObject(this.value_);\n      }\n\n    },\n\n    copyObject: function(object) {\n      var copy = Array.isArray(object) ? [] : {};\n      for (var prop in object) {\n        copy[prop] = object[prop];\n      }\n      if (Array.isArray(object))\n        copy.length = object.length;\n      return copy;\n    },\n\n    check_: function(changeRecords, skipChanges) {\n      var diff;\n      var oldValues;\n      if (hasObserve) {\n        if (!changeRecords)\n          return false;\n\n        oldValues = {};\n        diff = diffObjectFromChangeRecords(this.value_, changeRecords,\n                                           oldValues);\n      } else {\n        oldValues = this.oldObject_;\n        diff = diffObjectFromOldObject(this.value_, this.oldObject_);\n      }\n\n      if (diffIsEmpty(diff))\n        return false;\n\n      if (!hasObserve)\n        this.oldObject_ = this.copyObject(this.value_);\n\n      this.report_([\n        diff.added || {},\n        diff.removed || {},\n        diff.changed || {},\n        function(property) {\n          return oldValues[property];\n        }\n      ]);\n\n      return true;\n    },\n\n    disconnect_: function() {\n      if (hasObserve) {\n        this.directObserver_.close();\n        this.directObserver_ = undefined;\n      } else {\n        this.oldObject_ = undefined;\n      }\n    },\n\n    deliver: function() {\n      if (this.state_ != OPENED)\n        return;\n\n      if (hasObserve)\n        this.directObserver_.deliver(false);\n      else\n        dirtyCheck(this);\n    },\n\n    discardChanges: function() {\n      if (this.directObserver_)\n        this.directObserver_.deliver(true);\n      else\n        this.oldObject_ = this.copyObject(this.value_);\n\n      return this.value_;\n    }\n  });\n\n  function ArrayObserver(array) {\n    if (!Array.isArray(array))\n      throw Error('Provided object is not an Array');\n    ObjectObserver.call(this, array);\n  }\n\n  ArrayObserver.prototype = createObject({\n\n    __proto__: ObjectObserver.prototype,\n\n    arrayObserve: true,\n\n    copyObject: function(arr) {\n      return arr.slice();\n    },\n\n    check_: function(changeRecords) {\n      var splices;\n      if (hasObserve) {\n        if (!changeRecords)\n          return false;\n        splices = projectArraySplices(this.value_, changeRecords);\n      } else {\n        splices = calcSplices(this.value_, 0, this.value_.length,\n                              this.oldObject_, 0, this.oldObject_.length);\n      }\n\n      if (!splices || !splices.length)\n        return false;\n\n      if (!hasObserve)\n        this.oldObject_ = this.copyObject(this.value_);\n\n      this.report_([splices]);\n      return true;\n    }\n  });\n\n  ArrayObserver.applySplices = function(previous, current, splices) {\n    splices.forEach(function(splice) {\n      var spliceArgs = [splice.index, splice.removed.length];\n      var addIndex = splice.index;\n      while (addIndex < splice.index + splice.addedCount) {\n        spliceArgs.push(current[addIndex]);\n        addIndex++;\n      }\n\n      Array.prototype.splice.apply(previous, spliceArgs);\n    });\n  };\n\n  function PathObserver(object, path, defaultValue) {\n    Observer.call(this);\n\n    this.object_ = object;\n    this.path_ = getPath(path);\n    this.defaultValue_ = defaultValue;\n    this.directObserver_ = undefined;\n  }\n\n  PathObserver.prototype = createObject({\n    __proto__: Observer.prototype,\n\n    get path() {\n      return this.path_;\n    },\n\n    connect_: function() {\n      if (hasObserve)\n        this.directObserver_ = getObservedSet(this, this.object_);\n\n      this.check_(undefined, true);\n    },\n\n    disconnect_: function() {\n      this.value_ = undefined;\n\n      if (this.directObserver_) {\n        this.directObserver_.close(this);\n        this.directObserver_ = undefined;\n      }\n    },\n\n    iterateObjects_: function(observe) {\n      this.path_.iterateObjects(this.object_, observe);\n    },\n\n    check_: function(changeRecords, skipChanges) {\n      var oldValue = this.value_;\n      this.value_ = this.path_.getValueFrom(this.object_, this.defaultValue_);\n      if (skipChanges || areSameValue(this.value_, oldValue))\n        return false;\n\n      this.report_([this.value_, oldValue, this]);\n      return true;\n    },\n\n    setValue: function(newValue) {\n      if (this.path_)\n        this.path_.setValueFrom(this.object_, newValue);\n    }\n  });\n\n  function CompoundObserver(reportChangesOnOpen) {\n    Observer.call(this);\n\n    this.reportChangesOnOpen_ = reportChangesOnOpen;\n    this.value_ = [];\n    this.directObserver_ = undefined;\n    this.observed_ = [];\n  }\n\n  var observerSentinel = {};\n\n  CompoundObserver.prototype = createObject({\n    __proto__: Observer.prototype,\n\n    connect_: function() {\n      if (hasObserve) {\n        var object;\n        var needsDirectObserver = false;\n        for (var i = 0; i < this.observed_.length; i += 2) {\n          object = this.observed_[i];\n          if (object !== observerSentinel) {\n            needsDirectObserver = true;\n            break;\n          }\n        }\n\n        if (needsDirectObserver)\n          this.directObserver_ = getObservedSet(this, object);\n      }\n\n      this.check_(undefined, !this.reportChangesOnOpen_);\n    },\n\n    disconnect_: function() {\n      for (var i = 0; i < this.observed_.length; i += 2) {\n        if (this.observed_[i] === observerSentinel)\n          this.observed_[i + 1].close();\n      }\n      this.observed_.length = 0;\n      this.value_.length = 0;\n\n      if (this.directObserver_) {\n        this.directObserver_.close(this);\n        this.directObserver_ = undefined;\n      }\n    },\n\n    addPath: function(object, path) {\n      if (this.state_ != UNOPENED && this.state_ != RESETTING)\n        throw Error('Cannot add paths once started.');\n\n      path = getPath(path);\n      this.observed_.push(object, path);\n      if (!this.reportChangesOnOpen_)\n        return;\n      var index = this.observed_.length / 2 - 1;\n      this.value_[index] = path.getValueFrom(object);\n    },\n\n    addObserver: function(observer) {\n      if (this.state_ != UNOPENED && this.state_ != RESETTING)\n        throw Error('Cannot add observers once started.');\n\n      this.observed_.push(observerSentinel, observer);\n      if (!this.reportChangesOnOpen_)\n        return;\n      var index = this.observed_.length / 2 - 1;\n      this.value_[index] = observer.open(this.deliver, this);\n    },\n\n    startReset: function() {\n      if (this.state_ != OPENED)\n        throw Error('Can only reset while open');\n\n      this.state_ = RESETTING;\n      this.disconnect_();\n    },\n\n    finishReset: function() {\n      if (this.state_ != RESETTING)\n        throw Error('Can only finishReset after startReset');\n      this.state_ = OPENED;\n      this.connect_();\n\n      return this.value_;\n    },\n\n    iterateObjects_: function(observe) {\n      var object;\n      for (var i = 0; i < this.observed_.length; i += 2) {\n        object = this.observed_[i];\n        if (object !== observerSentinel)\n          this.observed_[i + 1].iterateObjects(object, observe);\n      }\n    },\n\n    check_: function(changeRecords, skipChanges) {\n      var oldValues;\n      for (var i = 0; i < this.observed_.length; i += 2) {\n        var object = this.observed_[i];\n        var path = this.observed_[i+1];\n        var value;\n        if (object === observerSentinel) {\n          var observable = path;\n          value = this.state_ === UNOPENED ?\n              observable.open(this.deliver, this) :\n              observable.discardChanges();\n        } else {\n          value = path.getValueFrom(object);\n        }\n\n        if (skipChanges) {\n          this.value_[i / 2] = value;\n          continue;\n        }\n\n        if (areSameValue(value, this.value_[i / 2]))\n          continue;\n\n        oldValues = oldValues || [];\n        oldValues[i / 2] = this.value_[i / 2];\n        this.value_[i / 2] = value;\n      }\n\n      if (!oldValues)\n        return false;\n\n      // TODO(rafaelw): Having observed_ as the third callback arg here is\n      // pretty lame API. Fix.\n      this.report_([this.value_, oldValues, this.observed_]);\n      return true;\n    }\n  });\n\n  function identFn(value) { return value; }\n\n  function ObserverTransform(observable, getValueFn, setValueFn,\n                             dontPassThroughSet) {\n    this.callback_ = undefined;\n    this.target_ = undefined;\n    this.value_ = undefined;\n    this.observable_ = observable;\n    this.getValueFn_ = getValueFn || identFn;\n    this.setValueFn_ = setValueFn || identFn;\n    // TODO(rafaelw): This is a temporary hack. PolymerExpressions needs this\n    // at the moment because of a bug in it's dependency tracking.\n    this.dontPassThroughSet_ = dontPassThroughSet;\n  }\n\n  ObserverTransform.prototype = {\n    open: function(callback, target) {\n      this.callback_ = callback;\n      this.target_ = target;\n      this.value_ =\n          this.getValueFn_(this.observable_.open(this.observedCallback_, this));\n      return this.value_;\n    },\n\n    observedCallback_: function(value) {\n      value = this.getValueFn_(value);\n      if (areSameValue(value, this.value_))\n        return;\n      var oldValue = this.value_;\n      this.value_ = value;\n      this.callback_.call(this.target_, this.value_, oldValue);\n    },\n\n    discardChanges: function() {\n      this.value_ = this.getValueFn_(this.observable_.discardChanges());\n      return this.value_;\n    },\n\n    deliver: function() {\n      return this.observable_.deliver();\n    },\n\n    setValue: function(value) {\n      value = this.setValueFn_(value);\n      if (!this.dontPassThroughSet_ && this.observable_.setValue)\n        return this.observable_.setValue(value);\n    },\n\n    close: function() {\n      if (this.observable_)\n        this.observable_.close();\n      this.callback_ = undefined;\n      this.target_ = undefined;\n      this.observable_ = undefined;\n      this.value_ = undefined;\n      this.getValueFn_ = undefined;\n      this.setValueFn_ = undefined;\n    }\n  };\n\n  var expectedRecordTypes = {\n    add: true,\n    update: true,\n    delete: true\n  };\n\n  function diffObjectFromChangeRecords(object, changeRecords, oldValues) {\n    var added = {};\n    var removed = {};\n\n    for (var i = 0; i < changeRecords.length; i++) {\n      var record = changeRecords[i];\n      if (!expectedRecordTypes[record.type]) {\n        console.error('Unknown changeRecord type: ' + record.type);\n        console.error(record);\n        continue;\n      }\n\n      if (!(record.name in oldValues))\n        oldValues[record.name] = record.oldValue;\n\n      if (record.type == 'update')\n        continue;\n\n      if (record.type == 'add') {\n        if (record.name in removed)\n          delete removed[record.name];\n        else\n          added[record.name] = true;\n\n        continue;\n      }\n\n      // type = 'delete'\n      if (record.name in added) {\n        delete added[record.name];\n        delete oldValues[record.name];\n      } else {\n        removed[record.name] = true;\n      }\n    }\n\n    var prop;\n    for (prop in added)\n      added[prop] = object[prop];\n\n    for (prop in removed)\n      removed[prop] = undefined;\n\n    var changed = {};\n    for (prop in oldValues) {\n      if (prop in added || prop in removed)\n        continue;\n\n      var newValue = object[prop];\n      if (oldValues[prop] !== newValue)\n        changed[prop] = newValue;\n    }\n\n    return {\n      added: added,\n      removed: removed,\n      changed: changed\n    };\n  }\n\n  function newSplice(index, removed, addedCount) {\n    return {\n      index: index,\n      removed: removed,\n      addedCount: addedCount\n    };\n  }\n\n  var EDIT_LEAVE = 0;\n  var EDIT_UPDATE = 1;\n  var EDIT_ADD = 2;\n  var EDIT_DELETE = 3;\n\n  function ArraySplice() {}\n\n  ArraySplice.prototype = {\n\n    // Note: This function is *based* on the computation of the Levenshtein\n    // \"edit\" distance. The one change is that \"updates\" are treated as two\n    // edits - not one. With Array splices, an update is really a delete\n    // followed by an add. By retaining this, we optimize for \"keeping\" the\n    // maximum array items in the original array. For example:\n    //\n    //   'xxxx123' -> '123yyyy'\n    //\n    // With 1-edit updates, the shortest path would be just to update all seven\n    // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\n    // leaves the substring '123' intact.\n    calcEditDistances: function(current, currentStart, currentEnd,\n                                old, oldStart, oldEnd) {\n      // \"Deletion\" columns\n      var rowCount = oldEnd - oldStart + 1;\n      var columnCount = currentEnd - currentStart + 1;\n      var distances = new Array(rowCount);\n\n      var i, j;\n\n      // \"Addition\" rows. Initialize null column.\n      for (i = 0; i < rowCount; i++) {\n        distances[i] = new Array(columnCount);\n        distances[i][0] = i;\n      }\n\n      // Initialize null row\n      for (j = 0; j < columnCount; j++)\n        distances[0][j] = j;\n\n      for (i = 1; i < rowCount; i++) {\n        for (j = 1; j < columnCount; j++) {\n          if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))\n            distances[i][j] = distances[i - 1][j - 1];\n          else {\n            var north = distances[i - 1][j] + 1;\n            var west = distances[i][j - 1] + 1;\n            distances[i][j] = north < west ? north : west;\n          }\n        }\n      }\n\n      return distances;\n    },\n\n    // This starts at the final weight, and walks \"backward\" by finding\n    // the minimum previous weight recursively until the origin of the weight\n    // matrix.\n    spliceOperationsFromEditDistances: function(distances) {\n      var i = distances.length - 1;\n      var j = distances[0].length - 1;\n      var current = distances[i][j];\n      var edits = [];\n      while (i > 0 || j > 0) {\n        if (i == 0) {\n          edits.push(EDIT_ADD);\n          j--;\n          continue;\n        }\n        if (j == 0) {\n          edits.push(EDIT_DELETE);\n          i--;\n          continue;\n        }\n        var northWest = distances[i - 1][j - 1];\n        var west = distances[i - 1][j];\n        var north = distances[i][j - 1];\n\n        var min;\n        if (west < north)\n          min = west < northWest ? west : northWest;\n        else\n          min = north < northWest ? north : northWest;\n\n        if (min == northWest) {\n          if (northWest == current) {\n            edits.push(EDIT_LEAVE);\n          } else {\n            edits.push(EDIT_UPDATE);\n            current = northWest;\n          }\n          i--;\n          j--;\n        } else if (min == west) {\n          edits.push(EDIT_DELETE);\n          i--;\n          current = west;\n        } else {\n          edits.push(EDIT_ADD);\n          j--;\n          current = north;\n        }\n      }\n\n      edits.reverse();\n      return edits;\n    },\n\n    /**\n     * Splice Projection functions:\n     *\n     * A splice map is a representation of how a previous array of items\n     * was transformed into a new array of items. Conceptually it is a list of\n     * tuples of\n     *\n     *   <index, removed, addedCount>\n     *\n     * which are kept in ascending index order of. The tuple represents that at\n     * the |index|, |removed| sequence of items were removed, and counting forward\n     * from |index|, |addedCount| items were added.\n     */\n\n    /**\n     * Lacking individual splice mutation information, the minimal set of\n     * splices can be synthesized given the previous state and final state of an\n     * array. The basic approach is to calculate the edit distance matrix and\n     * choose the shortest path through it.\n     *\n     * Complexity: O(l * p)\n     *   l: The length of the current array\n     *   p: The length of the old array\n     */\n    calcSplices: function(current, currentStart, currentEnd,\n                          old, oldStart, oldEnd) {\n      var prefixCount = 0;\n      var suffixCount = 0;\n\n      var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n      if (currentStart == 0 && oldStart == 0)\n        prefixCount = this.sharedPrefix(current, old, minLength);\n\n      if (currentEnd == current.length && oldEnd == old.length)\n        suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);\n\n      currentStart += prefixCount;\n      oldStart += prefixCount;\n      currentEnd -= suffixCount;\n      oldEnd -= suffixCount;\n\n      if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)\n        return [];\n\n      var splice;\n      if (currentStart == currentEnd) {\n        splice = newSplice(currentStart, [], 0);\n        while (oldStart < oldEnd)\n          splice.removed.push(old[oldStart++]);\n\n        return [ splice ];\n      } else if (oldStart == oldEnd)\n        return [ newSplice(currentStart, [], currentEnd - currentStart) ];\n\n      var ops = this.spliceOperationsFromEditDistances(\n          this.calcEditDistances(current, currentStart, currentEnd,\n                                 old, oldStart, oldEnd));\n\n      var splices = [];\n      var index = currentStart;\n      var oldIndex = oldStart;\n      for (var i = 0; i < ops.length; i++) {\n        switch(ops[i]) {\n          case EDIT_LEAVE:\n            if (splice) {\n              splices.push(splice);\n              splice = undefined;\n            }\n\n            index++;\n            oldIndex++;\n            break;\n          case EDIT_UPDATE:\n            if (!splice)\n              splice = newSplice(index, [], 0);\n\n            splice.addedCount++;\n            index++;\n\n            splice.removed.push(old[oldIndex]);\n            oldIndex++;\n            break;\n          case EDIT_ADD:\n            if (!splice)\n              splice = newSplice(index, [], 0);\n\n            splice.addedCount++;\n            index++;\n            break;\n          case EDIT_DELETE:\n            if (!splice)\n              splice = newSplice(index, [], 0);\n\n            splice.removed.push(old[oldIndex]);\n            oldIndex++;\n            break;\n        }\n      }\n\n      if (splice) {\n        splices.push(splice);\n      }\n      return splices;\n    },\n\n    sharedPrefix: function(current, old, searchLength) {\n      for (var i = 0; i < searchLength; i++)\n        if (!this.equals(current[i], old[i]))\n          return i;\n      return searchLength;\n    },\n\n    sharedSuffix: function(current, old, searchLength) {\n      var index1 = current.length;\n      var index2 = old.length;\n      var count = 0;\n      while (count < searchLength && this.equals(current[--index1], old[--index2]))\n        count++;\n\n      return count;\n    },\n\n    calculateSplices: function(current, previous) {\n      return this.calcSplices(current, 0, current.length, previous, 0,\n                              previous.length);\n    },\n\n    equals: function(currentValue, previousValue) {\n      return currentValue === previousValue;\n    }\n  };\n\n  var arraySplice = new ArraySplice();\n\n  function calcSplices(current, currentStart, currentEnd,\n                       old, oldStart, oldEnd) {\n    return arraySplice.calcSplices(current, currentStart, currentEnd,\n                                   old, oldStart, oldEnd);\n  }\n\n  function intersect(start1, end1, start2, end2) {\n    // Disjoint\n    if (end1 < start2 || end2 < start1)\n      return -1;\n\n    // Adjacent\n    if (end1 == start2 || end2 == start1)\n      return 0;\n\n    // Non-zero intersect, span1 first\n    if (start1 < start2) {\n      if (end1 < end2)\n        return end1 - start2; // Overlap\n      else\n        return end2 - start2; // Contained\n    } else {\n      // Non-zero intersect, span2 first\n      if (end2 < end1)\n        return end2 - start1; // Overlap\n      else\n        return end1 - start1; // Contained\n    }\n  }\n\n  function mergeSplice(splices, index, removed, addedCount) {\n\n    var splice = newSplice(index, removed, addedCount);\n\n    var inserted = false;\n    var insertionOffset = 0;\n\n    for (var i = 0; i < splices.length; i++) {\n      var current = splices[i];\n      current.index += insertionOffset;\n\n      if (inserted)\n        continue;\n\n      var intersectCount = intersect(splice.index,\n                                     splice.index + splice.removed.length,\n                                     current.index,\n                                     current.index + current.addedCount);\n\n      if (intersectCount >= 0) {\n        // Merge the two splices\n\n        splices.splice(i, 1);\n        i--;\n\n        insertionOffset -= current.addedCount - current.removed.length;\n\n        splice.addedCount += current.addedCount - intersectCount;\n        var deleteCount = splice.removed.length +\n                          current.removed.length - intersectCount;\n\n        if (!splice.addedCount && !deleteCount) {\n          // merged splice is a noop. discard.\n          inserted = true;\n        } else {\n          removed = current.removed;\n\n          if (splice.index < current.index) {\n            // some prefix of splice.removed is prepended to current.removed.\n            var prepend = splice.removed.slice(0, current.index - splice.index);\n            Array.prototype.push.apply(prepend, removed);\n            removed = prepend;\n          }\n\n          if (splice.index + splice.removed.length > current.index + current.addedCount) {\n            // some suffix of splice.removed is appended to current.removed.\n            var append = splice.removed.slice(current.index + current.addedCount - splice.index);\n            Array.prototype.push.apply(removed, append);\n          }\n\n          splice.removed = removed;\n          if (current.index < splice.index) {\n            splice.index = current.index;\n          }\n        }\n      } else if (splice.index < current.index) {\n        // Insert splice here.\n\n        inserted = true;\n\n        splices.splice(i, 0, splice);\n        i++;\n\n        var offset = splice.addedCount - splice.removed.length;\n        current.index += offset;\n        insertionOffset += offset;\n      }\n    }\n\n    if (!inserted)\n      splices.push(splice);\n  }\n\n  function createInitialSplices(array, changeRecords) {\n    var splices = [];\n\n    for (var i = 0; i < changeRecords.length; i++) {\n      var record = changeRecords[i];\n      switch(record.type) {\n        case 'splice':\n          mergeSplice(splices, record.index, record.removed.slice(), record.addedCount);\n          break;\n        case 'add':\n        case 'update':\n        case 'delete':\n          if (!isIndex(record.name))\n            continue;\n          var index = toNumber(record.name);\n          if (index < 0)\n            continue;\n          mergeSplice(splices, index, [record.oldValue], 1);\n          break;\n        default:\n          console.error('Unexpected record type: ' + JSON.stringify(record));\n          break;\n      }\n    }\n\n    return splices;\n  }\n\n  function projectArraySplices(array, changeRecords) {\n    var splices = [];\n\n    createInitialSplices(array, changeRecords).forEach(function(splice) {\n      if (splice.addedCount == 1 && splice.removed.length == 1) {\n        if (splice.removed[0] !== array[splice.index])\n          splices.push(splice);\n\n        return;\n      }\n\n      splices = splices.concat(calcSplices(array, splice.index, splice.index + splice.addedCount,\n                                           splice.removed, 0, splice.removed.length));\n    });\n\n    return splices;\n  }\n\n  // Export the observe-js object for **Node.js**, with backwards-compatibility\n  // for the old `require()` API. Also ensure `exports` is not a DOM Element.\n  // If we're in the browser, export as a global object.\n\n  var expose = global;\n\n  if (typeof exports !== 'undefined' && !exports.nodeType) {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports;\n    }\n    expose = exports;\n  }\n\n  expose.Observer = Observer;\n  expose.Observer.runEOM_ = runEOM;\n  expose.Observer.observerSentinel_ = observerSentinel; // for testing.\n  expose.Observer.hasObjectObserve = hasObserve;\n  expose.ArrayObserver = ArrayObserver;\n  expose.ArrayObserver.calculateSplices = function(current, previous) {\n    return arraySplice.calculateSplices(current, previous);\n  };\n\n  expose.ArraySplice = ArraySplice;\n  expose.ObjectObserver = ObjectObserver;\n  expose.PathObserver = PathObserver;\n  expose.CompoundObserver = CompoundObserver;\n  expose.Path = Path;\n  expose.ObserverTransform = ObserverTransform;\n\n})(typeof global !== 'undefined' && global && typeof module !== 'undefined' && module ? global : this || window);\n"]}